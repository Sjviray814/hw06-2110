#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "gba.h"
#include "numberGenerators.h"
#include "images/CoverImage.h"
#include "images/endImage.h"
#include "images/hi_score.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  LOSE,
  HOW
};
int numFoods = 0;
int foodsSpawned = 0;
int instructions = 0;
u16 instructionColor;
int difficulty = 0;

int titleSelection = 0;
int titleDrawn = 0;

int score = 0;
int scoreDrawn = 0;

int howDrawn = 0;

int highScore = 0;

int loseDrawn = 0;

int newHighScore = 0;

int seed = 0;


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct Player *player1 = malloc(sizeof(struct Player));
  if (player1 == NULL) {
      return 1;
  }
  player1->color = WHITE;
  player1->height = PLAYER_HEIGHT;
  player1->width = PLAYER_WIDTH;
  player1->xPos = (WIDTH / 2) - (player1->width / 2);
  player1->yPos = (HEIGHT / 2) - (player1->height / 2);
  player1->yVel = 0;
  player1->xVel = 0;

  struct Food foods[9];


  while (1) {
    seed = (seed + 1) % 1000000;
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    /*
      Start: Enter
      Select: Backspace
      A: Z
      B: X
      L: A
      R: S
    */

    waitForVBlank();
    switch (state) {
      
      case START:
        if (!titleDrawn) {
          drawFullScreenImageDMA(CoverImage);
          drawTitle(titleSelection);
          if (newHighScore) {
            drawNewHighScore();
          }
          titleDrawn = 1;
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons) && !(KEY_DOWN(BUTTON_DOWN, previousButtons))) {
            drawPartialTitle((titleSelection + 1) % 4, titleSelection);
            titleSelection = (titleSelection + 1) % 4;
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons) && !(KEY_DOWN(BUTTON_UP, previousButtons))) {
          if (titleSelection == 0) {
            drawPartialTitle(3, 0);
            titleSelection = 3;
          } else {
            drawPartialTitle(titleSelection - 1, titleSelection);
            titleSelection = (titleSelection - 1);
          }
        }

        if (KEY_DOWN(BUTTON_START, currentButtons) && !(KEY_DOWN(BUTTON_START, previousButtons))) {
            srand(seed);
            player1->color = WHITE;
            if (titleSelection != 3) {
              fillScreenDMA(BACKGROUND_COLOR);
              difficulty = titleSelection + 1;
              spawnFoods(foods, difficulty, player1);
              newHighScore = 0;
              state = PLAY;
            } else {
              state = HOW;
            }
        }
      
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          resetEverything();
          state = START;
        }

        // state = ?
        break;
      case PLAY:
        controlPlayer(player1, currentButtons);
        movePlayer(player1, 1);

        // if (KEY_DOWN(BUTTON_START, currentButtons) && !(KEY_DOWN(BUTTON_START, previousButtons))) {
        //   spawnFoods(foods, difficulty);
        // }
        if (numFoods > 0 && foodsSpawned) {
          drawFoods(foods, numFoods);
        }
        if (!scoreDrawn) {
          drawScore();
        }

        for (int i = 0; i < numFoods; i++) {
          if (checkCollision(player1, &foods[i])) {
              player1->color = foods[i].color;
              if (foods[i].color == instructionColor) {
                score++;
              } else {
                if (score > highScore) {
                  highScore = score;
                  newHighScore = 1;
                }
                state = LOSE;
              }
              scoreDrawn = 0;
              drawScore();
              undrawFoods(foods, numFoods);
              spawnFoods(foods, difficulty, player1);
              drawInstructions(difficulty);
              break;
          }
        }

        if (!instructions) {
          drawInstructions(difficulty);
        }

        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          resetEverything();
          state = START;
        }
        

        // state = ?
        break;


      case LOSE:

      if (!loseDrawn) {
        drawLose();
        loseDrawn = 1;
      }

      if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
        resetEverything();
        state = START;
      }

      if (KEY_DOWN(BUTTON_START, currentButtons)) {
        softReset();
        state = START;
      }

        // state = ?
        break;

      case HOW:

      if (!howDrawn) {
        fillScreenDMA(BACKGROUND_COLOR);
        drawHow();
        howDrawn = 1;
      }

      if (KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
        softReset();
        state = START;
      }
      if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
        resetEverything();
        state = START;
      }


      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons);

  free(player1);
  return 0;
}

void drawTitle(int selection) {
  u16 colorChoices[] = {WHITE, WHITE, WHITE, WHITE};
  colorChoices[selection] = RED;
  // waitForVBlank();
  drawCenteredString(70, 115, 10, 10, "Easy", colorChoices[0]);
  // waitForVBlank();
  drawCenteredString(90, 115, 10, 10, "Medium", colorChoices[1]);
  // waitForVBlank();
  drawCenteredString(110, 115, 10, 10, "Hard", colorChoices[2]);
  // waitForVBlank();
  drawCenteredString(130, 115, 10, 10, "How to Play?", colorChoices[3]);
  // waitForVBlank();
  drawCenteredString(145, 110, 10, 10, "High Score: ", GREEN);
  char hiScore[20];
  sprintf(hiScore, "%d", highScore);
  // waitForVBlank();
  drawCenteredString(145, 150, 10, 10, hiScore, GREEN);
}

void drawPartialTitle(int selection, int prevSelection) {
  // waitForVBlank();
  switch (prevSelection) {
    case 0:
      drawCenteredString(70, 115, 10, 10, "Easy", WHITE);
      break;
    case 1:
      drawCenteredString(90, 115, 10, 10, "Medium", WHITE);
      break;
    case 2:
      drawCenteredString(110, 115, 10, 10, "Hard", WHITE);
      break;
    case 3:
      drawCenteredString(130, 115, 10, 10, "How to Play?", WHITE);
      break;
  }
  switch (selection) {
      case 0:
        drawCenteredString(70, 115, 10, 10, "Easy", RED);
        break;
      case 1:
        drawCenteredString(90, 115, 10, 10, "Medium", RED);
        break;
      case 2:
        drawCenteredString(110, 115, 10, 10, "Hard", RED);
        break;
      case 3:
        drawCenteredString(130, 115, 10, 10, "How to Play?", RED);
        break;
  }
}



void controlPlayer(struct Player *player, u32 buttons) {
  if (KEY_DOWN(BUTTON_UP, buttons)) {
    player->yVel = -1;
  } else if (KEY_DOWN(BUTTON_DOWN, buttons)) {
      player->yVel = 1;
  } else {
      player->yVel = 0;
  }
  
  if (KEY_DOWN(BUTTON_LEFT, buttons)) {
      player->xVel = -1;
  } else if (KEY_DOWN(BUTTON_RIGHT, buttons)) {
      player->xVel = 1;
  } else {
      player->xVel = 0;
  }
}
void movePlayer(struct Player *player, float playerSpeed) {
// Store old position before moving
  int oldX = player->xPos;
  int oldY = player->yPos;

  // Update position based on velocity
  if (fabs(player->xVel) > 0 && fabs(player->yVel) > 0) {
    player->xPos += 0.707 * (player->xVel * playerSpeed);
    player->yPos += 0.707 * (player->yVel * playerSpeed);
  } else {
    player->xPos += player->xVel * playerSpeed;
    player->yPos += player->yVel * playerSpeed;
  }
  

  // Stop at screen edges
  if (player->xPos < 0) {
    player->xPos = 0;
  } else if (player->xPos + player->width > WIDTH) {
    player->xPos = WIDTH - player->width;
  }

  if (player->yPos < 10) {
    player->yPos = 10;
  } else if (player->yPos + player->height > HEIGHT - 10) {
    player->yPos = HEIGHT - player->height - 10;
  }

  // waitForVBlank();
  // Erase the old player position
  if (player->xPos != oldX) {
      drawRectDMA(oldY, oldX, player->width, player->height, BACKGROUND_COLOR);
  }

  if (player->yPos != oldY) {
      drawRectDMA(oldY, oldX, player->width, player->height, BACKGROUND_COLOR);
  }

  // Draw the player at the new position
  drawRectDMA(player->yPos, player->xPos, player->width, player->height, player->color);
}


void spawnFoods(struct Food foods[], int difficulty, struct Player *player) {
  u16 colors[] = {WHITE, RED, GREEN, BLUE, MAGENTA, CYAN, YELLOW, BROWN, GRAY};
  numFoods = difficulty * 3;
  if (difficulty == 2) {
    numFoods = 5;
  }
  for (int i = 0; i < numFoods; i++) {
      foods[i].xPos = rand() % (WIDTH - FOOD_WIDTH);
      foods[i].yPos = rand() % (HEIGHT - FOOD_HEIGHT - 30) + 30;
      if (checkCollision(player, &foods[i])) {
          i--;
          continue;
      }
      foods[i].color = colors[i];
  }
  foodsSpawned = 1;
}
void drawFoods(struct Food foods[], int numFoods) {
  for (int i = 0; i < numFoods; i++) {
      struct Food food = foods[i];  
      // waitForVBlank();
      drawRectDMA(food.yPos, food.xPos, FOOD_WIDTH, FOOD_HEIGHT, food.color);
  }
  foodsSpawned = 0;
}
void undrawFoods(struct Food foods[], int numFoods) {
  for (int i = 0; i < numFoods; i++) {
    struct Food food = foods[i];  
    // waitForVBlank();
    drawRectDMA(food.yPos, food.xPos, FOOD_WIDTH, FOOD_HEIGHT, BACKGROUND_COLOR);
  }
}
int checkCollision(struct Player *player, struct Food *food) {
  return !(player->xPos + player->width <= food->xPos ||
           player->xPos >= food->xPos + FOOD_WIDTH ||
           player->yPos + player->height <= food->yPos ||
           player->yPos >= food->yPos + FOOD_HEIGHT);
}

void drawInstructions(int difficulty) {
    u16 colors[] = {WHITE, RED, GREEN, BLUE, MAGENTA, CYAN, YELLOW, BROWN, GRAY};
    char* colorNames[] = {"White", "Red", "Green", "Blue", "Magenta", "Cyan", "Yellow", "Brown", "Gray"};

    if (difficulty == 1) {
      int instructionIndex = rand() % (difficulty * 3);
      instructionColor = colors[instructionIndex];
      // waitForVBlank();
      drawRectDMA(10, 0, 100, 10, BACKGROUND_COLOR);

      int otherColorOrder = generateTwoDigitNumber(instructionIndex); // Generates a random 2-digit number containing 0,1,2 and not instructionIndex

      // waitForVBlank();
      drawCenteredString(10, 20, 10, 10, colorNames[otherColorOrder % 10], colors[otherColorOrder / 10]);
    } else if (difficulty == 2) {
      int instructionIndex = rand() % 5;
      instructionColor = colors[instructionIndex];

      // waitForVBlank();
      drawRectDMA(10, 0, 100, 10, BACKGROUND_COLOR);

      int otherColorOrder = generateFourDigitNumber(instructionIndex); // Generates a random 4-digit number containing 0,1,2,3,4 and not instructionIndex

      // waitForVBlank();
      drawCenteredString(10, 20, 10, 10, colorNames[otherColorOrder % 10], colors[(otherColorOrder / 10) % 10]);
      otherColorOrder /= 100;
      // waitForVBlank();
      drawCenteredString(10, 70, 10, 10, colorNames[otherColorOrder % 10], colors[otherColorOrder / 10]);
    } else if (difficulty == 3) {
      int instructionIndex = rand() % 9;
      instructionColor = colors[instructionIndex];

      // waitForVBlank();
      drawRectDMA(10, 0, 200, 10, BACKGROUND_COLOR);

      int otherColorOrder = generateEightDigitNumber(instructionIndex); // Generates a random 8-digit number containing not instructionIndex

      for (int i = 0; i < 4; i++) {
        // waitForVBlank();
        drawCenteredString(10, 20 + (50 * i), 10, 10, colorNames[otherColorOrder % 10], colors[(otherColorOrder / 10) % 10]);
        otherColorOrder /= 100;
      }
    }
    instructions = 1;
}
void drawScore(void) {
    // waitForVBlank();
    drawRectDMA(5, 680, 30, 10, BACKGROUND_COLOR);
    char scoreStr[20];
    sprintf(scoreStr, "%d", score);
    if (!scoreDrawn) {
      // waitForVBlank();
      drawCenteredString(7, 700, 10, 10, scoreStr, WHITE);
    }
    scoreDrawn = 1;
}

void resetEverything(void) {
  // fillScreenDMA(BACKGROUND_COLOR);
  numFoods = 0;
  foodsSpawned = 0;
  instructions = 0;
  difficulty = 0;

  titleSelection = 0;
  titleDrawn = 0;

  score = 0;
  scoreDrawn = 0;

  howDrawn = 0;

  loseDrawn = 0;

  highScore = 0;
  newHighScore = 0;
}
void softReset(void) {
  numFoods = 0;
  foodsSpawned = 0;
  instructions = 0;
  difficulty = 0;

  titleSelection = 0;
  titleDrawn = 0;

  score = 0;
  scoreDrawn = 0;

  howDrawn = 0;

  loseDrawn = 0;
}

void drawHow(void) {
  // waitForVBlank();
  drawString(10, 20, "Eat the color that is NOT", WHITE);
  drawString(20, 20, "in the clue. If the clue is:", WHITE);
  drawString(30, 20, "Red", GREEN);
  drawString(40, 20, "and the possible squares are ", WHITE);
  drawString(50, 20, "Red, Green and White, eat the", WHITE);
  drawString(60, 20, "white one because it does not", WHITE);
  drawString(70, 20, "show up in the word or color", WHITE);
  drawString(80, 20, "of the clue(s).", WHITE);
  drawString(90, 20, "Press Enter to return.", WHITE);
}

void drawLose(void) {
  // waitForVBlank();
  drawFullScreenImageDMA(endImage);
  // waitForVBlank();
  drawCenteredString(70, 115, 10, 10, "Your Score: ", WHITE);
  char scoreStr[20];
  sprintf(scoreStr, "%d", score);
  // waitForVBlank();
  drawCenteredString(70, 155, 10, 10, scoreStr, WHITE);

  drawCenteredString(85, 115, 10, 10, "High Score: ", GREEN);
  char hiScore[20];
  sprintf(hiScore, "%d", highScore);
  // waitForVBlank();
  drawCenteredString(85, 155, 10, 10, hiScore, GREEN);

  drawCenteredString(145, 115, 10, 10, "Press Enter", WHITE);
}

void drawNewHighScore(void) {
    // waitForVBlank();
    drawImageDMA(125, 170, 30, 30, hi_score);
}